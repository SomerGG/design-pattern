## 设计模式
#### 设计模式的类型
- 创建型模式
    - 工厂模式
    - 抽象工厂模式
    - 单例模式
    - 建造者模式
    - 原型模式
- 结构型模式
    - 适配器模式
    - 桥接模式
    - 过滤器模式
    - 组合模式
    - 装饰器模式
    - 外观模式
    - 享元模式
    - 代理模式
- 行为型模式
    - 责任链模式
    - 命令模式
    - 解释器模式
    - 迭代器模式
    - 中介者模式
    - 备忘录模式
    - 观察者模式
    - 状态模式
    - 空对象模式
    - 策略模式
    - 模板模式
    - 访问者模式
- J2EE 模式
    - MVC 模式
    - 业务代表模式
    - 组合实体模式
    - 数据访问对象模式
    - 前端控制器模式
    - 拦截过滤器模式
    - 服务定位器模式
    - 传输对象模式
#### 七大原则
- 单一原则：一个类或接口、方法只做一件事；
- 开闭原则：对扩展开放，对修改关闭；
- 里氏代换原则：子类可以复用父类的功能，但是不能改变父类的功能；
- 依赖倒置原则：通过接口或抽象类，使得各模块之间不相互影响，实现松耦合；
- 接口隔离原则：降低耦合度，接口单独设计，互相隔离；
- 迪米特法则，又称最少知道原则：功能模块尽量独立；
- 合成复用原则：尽量使用聚合，组合，而不是继承。

### 工厂模式
**简单工厂模式**  
定义：指由一个工厂对象决定创建出哪一种产品类的实例。根据传入的参数，工厂根据判断逻辑生成相应的对象实例。 

适用场景：客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。

优点：只需要传入一个正确的参数，就可以得到所需要的对象，对于创建的过程无须关注。

缺点：工厂类的职责过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。

**工厂方法模式**  
定义：定义一个创建对象的接口，但是让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。
每一个工厂生成各自对应的实例。

适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节。一个类通过其子类来指定创建哪个对象。

优点：用户只需关心所需产品对应到工厂，无须关心创建细节；加入新产品符合开闭原则，提供来系统的可扩展性。

缺点：类的个数容易过多，增加了代码结构的复杂度；增加了系统的抽象性和理解难度。

**抽象工厂模式**  
定义：指提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。

适用场景：客户端不依赖于产品类实例如何被创建、实现等细节；强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要
大量重复的代码；提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

优点：具体产品在应用层代码隔离，无须关心创建细节；将一个系列的产品族统一到一起创建。

缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口，违背了开闭原则；
增加了系统的抽象性和理解难度。

### 单例模式  
定义：确保一个类在任意情况下都绝对只有一个实例，并提供一个全局访问点。

适用场景：确保任何情况下都只有一个实例。例如：ServletContext、ServletConfig、ApplicationContext、DBPool

**饿汉式单例**  
在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没有出现之前就已经实例化了，
不可能存在访问安全问题。  

优点：没有加任何的锁、执行效率高，用户体验上比懒汉式好。

缺点：类加载的时候就进行初始化，不管用不用都占着空间，浪费内存空间。

Spring 中 ioc 容器 ApplicationContext 本身就是典型的饿汉式单例。


**懒汉式单例**  
被外部类调用时才会加载。

简单懒汉式，通过给对象实例化的方法加锁 synchronized 进行返回唯一实例并保障线程安全，缺点是效率低，在线程数量较多，
如果 CPU 分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅度下降。

通过 synchronized、volatile 关键字的双重检查锁来保障线程安全和兼顾性能。当第一个线程调用对象初始化方法时，第二个
线程也可以调用该方法，当第一个线程进入 synchronized 时会上锁，第二个线程进入 Monitor 状态，出现阻塞，此时的阻塞
并不是基于整个类的阻塞，而是在实例化方法内部的阻塞，只要逻辑不是特别复杂，对于调用者而言感知不到。

通过类初始化的角度，使用内部类的方式来避免 synchronized 的性能消耗，利用内部类一定要在方法调用之前初始化，巧妙
避过线程安全问题。

**反射破坏单例**  
之前的单例模式（懒汉式和饿汉式）构造方法除了加上 private 以外，没有做任何处理，如果我们使用反射调用获取到私有的构造
方法，然后再调用初始化方法，就会生成两个不同的实例。通过在类的构造方法中加入限制（判断对象是否已经被初始化过）来防止
对象多次创建。

**序列化破坏单例**  
序列化：将对象在内存中的状态转换为字节码形式，从而转换为 IO 流，写入到其他地方（磁盘、网络 IO），将对象在内存中的地址
永久地保存下来  

反序列化：将保存的字节码转换为 IO 流，通过 IO 流的读取，将读取的内容转换为 Java 对象，在转换的过程中会重新创建对象
并分配地址。

重写 readResolve 方法防止反射破坏。

**注册式单例**  
将每一个实例都缓存到统一都容器中，使用唯一标识获取实例。  
枚举实现  
容器式单例实现

**单例模式优点**  
在内存中只有一个实例，减少内存的开销；避免对资源的多重占用；设置全局访问点，严格控制访问。

**单例模式的缺点**  
没有接口，扩展困难；如果要扩展单例对象，只能修改代码，违背了开闭原则；


### 原型模式  
定义：原型实例指定创建对象的种类，并且通过拷贝（克隆）这些原型创建新的对象。调用者不需要知道创建的细节，不用调用构造函数。
例如：BeanUtils.copy(), Json.parseObject(), Guava。

适用场景：
- 类初始化消耗资源较多
- new 一个对象需要非常繁琐的过程（数据准备、访问权限等）
- 构造函数比较复杂
- 循环体中生产大量的对象

**浅拷贝**  
对基本数据类型进行值传递，对引用数据类型进行引用传递（拷贝的是引用的地址），所有的引用对象
仍然指向原来的对象。

**深拷贝**  
对基本数据类型进行值传递，对引用数据类型，创建一个新对象，并复制其内容。

原型模式就是如何快速构建对象的方法总结，简单工厂将 setter、getter 封装到某个方法中。实现
JDK 提供的 Cloneable 接口，实现快速复制。

**原型模式的缺点**  
必须配备克隆方法；对克隆复杂对象或克隆出的对象进行复制改造时，易带来风险。

**克隆破坏单例**  
如果克隆的目标对象是单例对象，意味着深拷贝就会破坏单例，防止措施很简单，禁止深拷贝即可：要么
单例不实现 Cloneable 接口；要么重写 clone() 方法，在 clone 方法中返回单例对象即可。

**Arrays 的 copy 方法**  
实现 Cloneable 接口，调用 父类的 clone 方法，把对象内部的元素一个一个的迭代，再进行赋值，
最后调用 JVM 提供的 native 方法 arraycopy，然后重新分配内存给克隆后的新对象。


### 代理模式  
定义：为其他对象提供一种代理，以控制这个对象的访问。代理对象在客户端和目标对象之间起到中介作用。
属于结构型设计模式。

适用场景：保护目标对象；增强目标对象。

优点：将代理对象与真实被调用的目标对象分离；一定程度上降低了系统的耦合性，易于扩展；代理可以起到
保护目标对象的作用；增强目标对象的职责。

缺点：增加类的数目；在客户端和目标对象之前增加了代理对象，造成请求处理速度变慢；增加了
系统的复杂性。

**静态代理**  
显示地声明被代理的对象

缺点：如果目标对象的功能发生改变，代理类也需要跟着变动，违背了开闭原则。

**动态代理**  
动态配置和替换被代理的对象

**JDK 动态代理生成对象的步骤**
- 通过实现 InvocationHandler 接口来定义自己的 InvocationHandler。
- 通过构造方法获取到被代理类的引用，并且通过反射获取到它的所有接口和类加载器。
- 通过 JDK 的 Proxy.newProxyInstance(被代理类的类加载器, 被代理类的全部接口, 自定义的 InvocationHandler) 
方法重新生成一个实现了被代理类的新类，并且覆盖了被代理类所有接口的方法。
- 动态生成 Java 代码（在内存中完成），把增强的逻辑加入到新生成的代码中。
- 编译生成新的 Java 代码的 class 文件。
- 加载并运行新的 class 文件，生成代理对象。  
以上过程称为**字节码重组**

当代理对象生成之后，通过 InvocationHandler 的 Invoke() 调用目标对象的方法。当代理对象实例调用方法时，
将对方法的调用进行编码并将其指派到它的调用处理程序（InvocationHandler）的 invoke() 方法中，而 invoke() 
方法根据传入的代理对象、方法、参数来决定调用代理的哪个方法。

JDK 动态代理对目标对象的类型没有限制，但是被代理的类必须要实现一个接口，因为在生成代理类时，已经继承
了 Proxy 类，Java 不支持多继承，所以只能通过实现接口。JDK 内部会扫描接口里面的所有方法并进行覆盖（且覆盖后的方法都是 final 的），
并加入相关增强的逻辑，重新生成一个全新的 Proxy 类。

JDK 动态代理为什么会生成一个新的类？  
因为原来的类已经编译过了，无法进行修改，想在原来的类上进行功能增强，只能通过实现接口来重新生成一个全新的类，
并覆盖里面的方法，将增强的逻辑加入新的类中。

**JDK 动态代理使用条件**
- 必须实现 InvocationHandler 接口
- 使用 Proxy.newProxyInstance 产生代理对象
- 被代理的对象必须要实现接口


**CGLib 动态代理**  
CGLib 代理的目标对象不需要实现任何接口，它是通过继承目标对象实现的动态代理。

**代理过程**  
- 实现 MethodInterceptor 接口来自定义自己的拦截器
- 通过传入的目标类，使用 Enhancer 的 create 方法生成代理对象，设置父类为传入的目标类和设置回调为自定义拦截器
- 通过 cglib 的 MethodProxy.invokeSuper(代理对象, 要拦截方法的参数) 为代理类和被代理类各自生成
一个 Class
- 这个 Class 会为代理类和被代理类的方法分配一个 index(int 类型)。
- index 作为入参，FastClass 就可以直接定位到要调用的方法进行直接调用。

代理对象继承于目标类，拦截器调用 intercept() 方法， intercept() 方法由自定义的拦截器实现，所以，最后
调用自定义拦截器中的 intercept() 方法，完成了由代理对象调用目标对象的动态代理实现。


**JDK 动态代理和 cglib 动态代理对比**
- JDK 动态代理是实现了被代理对象的接口，而 cglib 动态代理是继承了被代理对象。
- JDK 动态代理和 cglib 动态代理都是在运行期间生成字节码，JDK 是直接写 Class 字节码，而 cglib 是使用
- cglib 不能代理 final 的方法。
- JDK 调用代理方法，是通过反射机制调用；cglib 是通过 FastClass 机制直接调用方法，所以 cglib 的执行效率更高。

**Spring 中代理模式选择**  
- 当 Bean 有实现接口时，使用 JDK 动态代理。
- 当 Bean 没有实现接口时，使用 cglib 动态代理。
- Spring 可以通过配置强制使用 cglib，只需要在 Spring 的配置文件中加入```
<aop:aspectj-autoproxy proxy-target-class="true" />```


### 委派模式
定义：作用就是负责任务的调用和分配任务，跟代理模式很像，可以看做一种特殊情况下的静态代理的全权代理，
但是代理模式注重过程，委派模式注重结果。Spring 的 DispatcherServlet 就使用了委派模式。

### 策略模式
定义：定义了算法家族、分别封装起来，让它们之间可以互相替换，使算法的变化不会影响到使用算法的用户。

可以避免多重分支的 if...else 和 switch 语句。

适用场景：系统中有很多类，而它们的区别仅仅在于它们的行为不同；一个系统需要动态地在几种算法中选择一种。

优点：符合开闭原则；结合工厂模式和单例模式，避免使用多重 if 判断；提高算法的保密性和安全性。

缺点：客户端必须知道所有的策略，并且自行决定使用哪一种策略；代码中会产生非常多的策略类，增加类维护的难度。


### 模板模式
定义：定义一个算法的骨架，并允许子类为一个或多个步骤提供实现。模板模式使得
子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。

适用场景：一次性实现某个算法的不可变部分，将可变的部分留给子类；各子类中公共的行为
被提取出来并集中到一个公共的父类中，从而避免代码重复。

典型的实例：jdbcTemplate

优点：提高代码复用性（相同逻辑抽取到父类）；提高代码的扩展性（将不同的代码在子类中进行实现）；
符合开闭原则。

缺点：类数目增加（抽象类不能直接 new，必须要有实现）；间接地增加了系统的复杂度；继承关系
自身的缺点，如果父类添加新的抽象方法，继承该类的所有子类全部都要改变。

### 适配器模式
定义：将一个类的接口转换成客户期望的另一个接口，使原本不兼容的类可以一起工作。
属于结构型设计模式。

优点：提高类的透明性和复用，现有的类复用但不需要改变；目标类和适配器类解藕，提高程序
的扩展性；在很多业务中符合开闭原则。

缺点：适配器编写过程中需要全面考虑，可能会增加系统的复杂性；增加代码的阅读难度，
降低阅读性，过多使用适配器模式会使系统代码变得凌乱。


### 装饰器模式
定义：在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更加有弹性的替代方案。

适用场景：用于扩展一个类的功能或给一个类添加些附加职责；动态地给一个对象添加功能，这些功能可以再动态地撤销。

优点：装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用；通过使用不同装饰类以及这些装饰类
的排列组合，可以实现不同的效果；装饰者模式遵守开闭原则。

缺点：会出现更多的代码，更多的类；动态装饰时，多层装饰会更复杂。

**装饰器模式和适配器模式对比**  
<table>
    <tr>
        <td></td>
        <td>装饰器模式</td>
        <td>适配器模式</td>
    </tr>
    <tr>
        <td>形式</td>
        <td>一种特别的适配器模式</td>
        <td>没有层级关系，装饰器模式有层级关系</td>
    </tr>
    <tr>
        <td>定义</td>
        <td>
        装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留 OOP 关系 
        </td>
        <td>
        适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装
        </td>
    </tr>
    <tr>
        <td>关系</td>
        <td>满足is-a的关系</td>
        <td>满足has-a的关系</td>
    </tr>
    <tr>
        <td>功能</td>
        <td>注重扩展、覆盖</td>
        <td>注重兼容、转换</td>
    </tr>
    <tr>
        <td>设计</td>
        <td>前置考虑</td>
        <td>后置考虑</td>
    </tr>                
</table>


### 观察者模式
定义：有时也叫做发布订阅模式。定义了对象之间的一对多依赖，让多个观察者同时监听一个主体对象，当主体对象发送变化时，它的所有依赖者
都会收到通知并更新。

适用场景：用于在关联行为之间建立一套触发机制的场景。
Spring 中的 ContextLoaderListener

优点：观察者和被观察者之间建立一个抽象的耦合；支持广播通信。

缺点：观察者之间有过多的细节依赖、增加了时间消耗和系统的复杂度；要适用得当，要避免循环调用。


### 设计模式对比与区别
**策略模式和工厂模式**  
1.工厂模式包含工厂方法和抽象工厂方法模式，是属于创建型模式，策略模式属于行为型模式。  
2.工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不同的行为。

**策略模式和委派模式**  
1.策略模式是委派模式内部的一种实现形式，关注的是能否使用不同的方式实现同样的目的。  
2.委派模式关注的是分发和调度的过程。

**模板方法模式和工厂方法模式**  
1.模板方法是一个算法可变的部分让子类去自己定义，但是不能改变算法的整体执行顺序。  
2.工厂方法算是模板方法的一种特殊实现，旨在将生成对象实例的过程延迟到子类中进行。

**模板方法模式和策略模式**  
1.模版方法和策略模式都有封装算法。  
2.策略模式是使用不同算法达到同样的目的，不影响客户端的使用。  
3.模板方法模式是针对一个算法的流程，将有差异的部分交给子类自己实现。  
4.模板方法模式不能改变算法的流程，策略模式可以改变且替换，策略模式通常用来替换 if...else 语句。

**装饰者模式和静态代理模式**  
1.装饰者模式注重给对象动态添加方法，而代理模式注重控制对象的访问。  
2.代理模式通常会在代理类中创建被代理对象的实例，装饰者模式通常会把被装饰者作为构造参数。

**装饰者模式和适配器模式**  
1.两者都属于包装器模式。  
2.装饰者模式旨在给对象添加方法，而适配器模式是在不改变原有基础上进行兼容。  
3.装饰者模式可以实现与被装饰者相同的接口或者继承被装饰者作为它的子类，而适配者和被适配者可以实现不同的接口。

**适配器模式和策略模式**  
1.适配器模式属于结构型，策略模式属于行为型模式。  
2.适配器是为了解决不兼容问题，而策略模式是使用不同的方法达到相同的目的。


### Spring 中常用设计模式
工厂模式：BeanFactory、Calendar  
单例模式：ApplicationContext、Calendar  
原型模式：PrototypeBean  
代理模式：ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy  
委派模式：DispatcherServlet、BeanDefinitionParseDelegate  
策略模式：InstantiationStrategy  
模板模式：JdbcTemplate、HttpServlet  
适配器模式：AdvisorAdapter、HandlerAdapter  
装饰器模式：InputStream、OutputStream  
观察者模式：ContextLoaderListener  

### Spring 中编程思想
OOP：Object Oriented Programing（面向对象编程），用程序归纳总结生活中的一切事物（转换需求为代码实现）。  
BOP：Bean Oriented Programing（面向 Bean 编程），用一个个的 Bean 来表示，不需要 new bean，只需要声明和
关注 bean 和 bean 之间的联系。  
AOP：Aspect Oriented Programing（面向切面编程），找出多个 bean 中有一定规律的代码，开发时将其拆开，
运行时再将其合并，面向切面编程，就是面向规则编程。  
IOC：Inversion Of Control（控制反转），将 new 对象的动作交给 Spring管理（Bean）Factory，并由
Spring 保存已创建的对象（IOC 容器）。  
DI/DL：Dependency Injection（依赖注入）或者 Dependency Lookup（依赖查找），Spring 不仅保存自己创建的对象，
而且保存对象与对象之间的关系。自动赋值，主要三种方式：构造注入方法、set 方法，直接赋值（反射）。


  




